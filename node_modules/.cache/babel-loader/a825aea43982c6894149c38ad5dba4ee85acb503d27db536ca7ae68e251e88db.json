{"ast":null,"code":"/**\n * @ignore\n * css3 selector engine for ie6-8\n * @author yiminghe@gmail.com\n */\n\nvar util = require('./query-selector/util');\nvar parser = require('./query-selector/parser');\nvar EXPANDO_SELECTOR_KEY = '_ks_data_selector_id_',\n  caches = {},\n  isContextXML,\n  uuid = 0,\n  subMatchesCache = {},\n  getAttr = function (el, name) {\n    if (isContextXML) {\n      return util.getSimpleAttr(el, name);\n    } else {\n      return util.attr(el, name);\n    }\n  },\n  hasSingleClass = util.hasSingleClass,\n  isTag = util.isTag,\n  aNPlusB = /^(([+-]?(?:\\d+)?)?n)?([+-]?\\d+)?$/;\n\n// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\nvar unescape = /\\\\([\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|.)/g,\n  unescapeFn = function (_, escaped) {\n    var high = '0x' + escaped - 0x10000;\n    // NaN means non-codepoint\n    return isNaN(high) ? escaped :\n    // BMP codepoint\n    high < 0 ? String.fromCharCode(high + 0x10000) :\n    // Supplemental Plane codepoint (surrogate pair)\n    String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n  };\nvar matchExpr;\nvar pseudoFnExpr = {\n  'nth-child': function (el, param) {\n    var ab = getAb(param),\n      a = ab.a,\n      b = ab.b;\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n    var index = 0,\n      parent = el.parentNode;\n    if (parent) {\n      var childNodes = parent.childNodes,\n        count = 0,\n        child,\n        ret,\n        len = childNodes.length;\n      for (; count < len; count++) {\n        child = childNodes[count];\n        if (child.nodeType === 1) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n    return 0;\n  },\n  'nth-last-child': function (el, param) {\n    var ab = getAb(param),\n      a = ab.a,\n      b = ab.b;\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n    var index = 0,\n      parent = el.parentNode;\n    if (parent) {\n      var childNodes = parent.childNodes,\n        len = childNodes.length,\n        count = len - 1,\n        child,\n        ret;\n      for (; count >= 0; count--) {\n        child = childNodes[count];\n        if (child.nodeType === 1) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n    return 0;\n  },\n  'nth-of-type': function (el, param) {\n    var ab = getAb(param),\n      a = ab.a,\n      b = ab.b;\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n    var index = 0,\n      parent = el.parentNode;\n    if (parent) {\n      var childNodes = parent.childNodes,\n        elType = el.tagName,\n        count = 0,\n        child,\n        ret,\n        len = childNodes.length;\n      for (; count < len; count++) {\n        child = childNodes[count];\n        if (child.tagName === elType) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n    return 0;\n  },\n  'nth-last-of-type': function (el, param) {\n    var ab = getAb(param),\n      a = ab.a,\n      b = ab.b;\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n    var index = 0,\n      parent = el.parentNode;\n    if (parent) {\n      var childNodes = parent.childNodes,\n        len = childNodes.length,\n        elType = el.tagName,\n        count = len - 1,\n        child,\n        ret;\n      for (; count >= 0; count--) {\n        child = childNodes[count];\n        if (child.tagName === elType) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n    return 0;\n  },\n  lang: function (el, lang) {\n    var elLang;\n    lang = unEscape(lang.toLowerCase());\n    do {\n      if (elLang = isContextXML ? el.getAttribute('xml:lang') || el.getAttribute('lang') : el.lang) {\n        elLang = elLang.toLowerCase();\n        return elLang === lang || elLang.indexOf(lang + '-') === 0;\n      }\n    } while ((el = el.parentNode) && el.nodeType === 1);\n    return false;\n  },\n  not: function (el, negationArg) {\n    return !matchExpr[negationArg.t](el, negationArg.value);\n  }\n};\nvar pseudoIdentExpr = {\n  empty: function (el) {\n    var childNodes = el.childNodes,\n      index = 0,\n      len = childNodes.length - 1,\n      child,\n      nodeType;\n    for (; index < len; index++) {\n      child = childNodes[index];\n      nodeType = child.nodeType;\n      // only element nodes and content nodes\n      // (such as Dom [Dom-LEVEL-3-CORE] text nodes,\n      // CDATA nodes, and entity references\n      if (nodeType === 1 || nodeType === 3 || nodeType === 4 || nodeType === 5) {\n        return 0;\n      }\n    }\n    return 1;\n  },\n  root: function (el) {\n    if (el.nodeType === 9) {\n      return true;\n    }\n    return el.ownerDocument && el === el.ownerDocument.documentElement;\n  },\n  'first-child': function (el) {\n    return pseudoFnExpr['nth-child'](el, 1);\n  },\n  'last-child': function (el) {\n    return pseudoFnExpr['nth-last-child'](el, 1);\n  },\n  'first-of-type': function (el) {\n    return pseudoFnExpr['nth-of-type'](el, 1);\n  },\n  'last-of-type': function (el) {\n    return pseudoFnExpr['nth-last-of-type'](el, 1);\n  },\n  'only-child': function (el) {\n    return pseudoIdentExpr['first-child'](el) && pseudoIdentExpr['last-child'](el);\n  },\n  'only-of-type': function (el) {\n    return pseudoIdentExpr['first-of-type'](el) && pseudoIdentExpr['last-of-type'](el);\n  },\n  focus: function (el) {\n    var doc = el.ownerDocument;\n    return doc && el === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(el.type || el.href || el.tabIndex >= 0);\n  },\n  target: function (el) {\n    var hash = location.hash;\n    return hash && hash.slice(1) === getAttr(el, 'id');\n  },\n  enabled: function (el) {\n    return !el.disabled;\n  },\n  disabled: function (el) {\n    return el.disabled;\n  },\n  checked: function (el) {\n    var nodeName = el.nodeName.toLowerCase();\n    return nodeName === 'input' && el.checked || nodeName === 'option' && el.selected;\n  }\n};\nvar attributeExpr = {\n  '~=': function (elValue, value) {\n    if (!value || value.indexOf(' ') > -1) {\n      return 0;\n    }\n    return (' ' + elValue + ' ').indexOf(' ' + value + ' ') !== -1;\n  },\n  '|=': function (elValue, value) {\n    return (' ' + elValue).indexOf(' ' + value + '-') !== -1;\n  },\n  '^=': function (elValue, value) {\n    return value && util.startsWith(elValue, value);\n  },\n  '$=': function (elValue, value) {\n    return value && util.endsWith(elValue, value);\n  },\n  '*=': function (elValue, value) {\n    return value && elValue.indexOf(value) !== -1;\n  },\n  '=': function (elValue, value) {\n    return elValue === value;\n  }\n};\nvar relativeExpr = {\n  '>': {\n    dir: 'parentNode',\n    immediate: 1\n  },\n  ' ': {\n    dir: 'parentNode'\n  },\n  '+': {\n    dir: 'previousSibling',\n    immediate: 1\n  },\n  '~': {\n    dir: 'previousSibling'\n  }\n};\nmatchExpr = {\n  tag: isTag,\n  cls: hasSingleClass,\n  id: function (el, value) {\n    return getAttr(el, 'id') === value;\n  },\n  attrib: function (el, value) {\n    var name = value.ident;\n    if (!isContextXML) {\n      name = name.toLowerCase();\n    }\n    var elValue = getAttr(el, name);\n    var match = value.match;\n    if (!match && elValue !== undefined) {\n      return 1;\n    } else if (match) {\n      if (elValue === undefined) {\n        return 0;\n      }\n      var matchFn = attributeExpr[match];\n      if (matchFn) {\n        return matchFn(elValue + '', value.value + '');\n      }\n    }\n    return 0;\n  },\n  pseudo: function (el, value) {\n    var fn, fnStr, ident;\n    if (fnStr = value.fn) {\n      if (!(fn = pseudoFnExpr[fnStr])) {\n        throw new SyntaxError('Syntax error: not support pseudo: ' + fnStr);\n      }\n      return fn(el, value.param);\n    }\n    if (ident = value.ident) {\n      if (!pseudoIdentExpr[ident]) {\n        throw new SyntaxError('Syntax error: not support pseudo: ' + ident);\n      }\n      return pseudoIdentExpr[ident](el);\n    }\n    return 0;\n  }\n};\nfunction unEscape(str) {\n  return str.replace(unescape, unescapeFn);\n}\nparser.lexer.yy = {\n  trim: util.trim,\n  unEscape: unEscape,\n  unEscapeStr: function (str) {\n    return this.unEscape(str.slice(1, -1));\n  }\n};\nfunction resetStatus() {\n  subMatchesCache = {};\n}\nfunction dir(el, direction) {\n  do {\n    el = el[direction];\n  } while (el && el.nodeType !== 1);\n  return el;\n}\nfunction getAb(param) {\n  var a = 0,\n    match,\n    b = 0;\n  if (typeof param === 'number') {\n    b = param;\n  } else if (param === 'odd') {\n    a = 2;\n    b = 1;\n  } else if (param === 'even') {\n    a = 2;\n    b = 0;\n  } else if (match = param.replace(/\\s/g, '').match(aNPlusB)) {\n    if (match[1]) {\n      a = parseInt(match[2], 10);\n      if (isNaN(a)) {\n        if (match[2] === '-') {\n          a = -1;\n        } else {\n          a = 1;\n        }\n      }\n    } else {\n      a = 0;\n    }\n    b = parseInt(match[3], 10) || 0;\n  }\n  return {\n    a: a,\n    b: b\n  };\n}\nfunction matchIndexByAb(index, a, b, eq) {\n  if (a === 0) {\n    if (index === b) {\n      return eq;\n    }\n  } else {\n    if ((index - b) / a >= 0 && (index - b) % a === 0 && eq) {\n      return 1;\n    }\n  }\n  return undefined;\n}\nfunction isXML(elem) {\n  var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n  return documentElement ? documentElement.nodeName.toLowerCase() !== 'html' : false;\n}\nfunction matches(str, seeds) {\n  return select(str, null, seeds);\n}\nfunction singleMatch(el, match) {\n  if (!match) {\n    return true;\n  }\n  if (!el) {\n    return false;\n  }\n  if (el.nodeType === 9) {\n    return false;\n  }\n  var matched = 1,\n    matchSuffix = match.suffix,\n    matchSuffixLen,\n    matchSuffixIndex;\n  if (match.t === 'tag') {\n    matched &= matchExpr.tag(el, match.value);\n  }\n  if (matched && matchSuffix) {\n    matchSuffixLen = matchSuffix.length;\n    matchSuffixIndex = 0;\n    for (; matched && matchSuffixIndex < matchSuffixLen; matchSuffixIndex++) {\n      var singleMatchSuffix = matchSuffix[matchSuffixIndex],\n        singleMatchSuffixType = singleMatchSuffix.t;\n      if (matchExpr[singleMatchSuffixType]) {\n        matched &= matchExpr[singleMatchSuffixType](el, singleMatchSuffix.value);\n      }\n    }\n  }\n  return matched;\n}\n\n// match by adjacent immediate single selector match\nfunction matchImmediate(el, match) {\n  var matched = 1,\n    startEl = el,\n    relativeOp,\n    startMatch = match;\n  do {\n    matched &= singleMatch(el, match);\n    if (matched) {\n      // advance\n      match = match && match.prev;\n      if (!match) {\n        return true;\n      }\n      relativeOp = relativeExpr[match.nextCombinator];\n      el = dir(el, relativeOp.dir);\n      if (!relativeOp.immediate) {\n        return {\n          // advance for non-immediate\n          el: el,\n          match: match\n        };\n      }\n    } else {\n      relativeOp = relativeExpr[match.nextCombinator];\n      if (relativeOp.immediate) {\n        // retreat but advance startEl\n        return {\n          el: dir(startEl, relativeExpr[startMatch.nextCombinator].dir),\n          match: startMatch\n        };\n      } else {\n        // advance (before immediate match + jump unmatched)\n        return {\n          el: el && dir(el, relativeOp.dir),\n          match: match\n        };\n      }\n    }\n  } while (el);\n\n  // only occur when match immediate\n  return {\n    el: dir(startEl, relativeExpr[startMatch.nextCombinator].dir),\n    match: startMatch\n  };\n}\n\n// find fixed part, fixed with seeds\nfunction findFixedMatchFromHead(el, head) {\n  var relativeOp,\n    cur = head;\n  do {\n    if (!singleMatch(el, cur)) {\n      return null;\n    }\n    cur = cur.prev;\n    if (!cur) {\n      return true;\n    }\n    relativeOp = relativeExpr[cur.nextCombinator];\n    el = dir(el, relativeOp.dir);\n  } while (el && relativeOp.immediate);\n  if (!el) {\n    return null;\n  }\n  return {\n    el: el,\n    match: cur\n  };\n}\nfunction genId(el) {\n  var selectorId;\n  if (isContextXML) {\n    if (!(selectorId = el.getAttribute(EXPANDO_SELECTOR_KEY))) {\n      el.setAttribute(EXPANDO_SELECTOR_KEY, selectorId = +new Date() + '_' + ++uuid);\n    }\n  } else {\n    if (!(selectorId = el[EXPANDO_SELECTOR_KEY])) {\n      selectorId = el[EXPANDO_SELECTOR_KEY] = +new Date() + '_' + ++uuid;\n    }\n  }\n  return selectorId;\n}\nfunction matchSub(el, match) {\n  var selectorId = genId(el),\n    matchKey;\n  matchKey = selectorId + '_' + (match.order || 0);\n  if (matchKey in subMatchesCache) {\n    return subMatchesCache[matchKey];\n  }\n  subMatchesCache[matchKey] = matchSubInternal(el, match);\n  return subMatchesCache[matchKey];\n}\n\n// recursive match by sub selector string from right to left\n// grouped by immediate selectors\nfunction matchSubInternal(el, match) {\n  var matchImmediateRet = matchImmediate(el, match);\n  if (matchImmediateRet === true) {\n    return true;\n  } else {\n    el = matchImmediateRet.el;\n    match = matchImmediateRet.match;\n    while (el) {\n      if (matchSub(el, match)) {\n        return true;\n      }\n      el = dir(el, relativeExpr[match.nextCombinator].dir);\n    }\n    return false;\n  }\n}\nfunction select(str, context, seeds) {\n  if (!caches[str]) {\n    caches[str] = parser.parse(str);\n  }\n  var selector = caches[str],\n    groupIndex = 0,\n    groupLen = selector.length,\n    contextDocument,\n    group,\n    ret = [];\n  if (seeds) {\n    context = context || seeds[0].ownerDocument;\n  }\n  contextDocument = context && context.ownerDocument || typeof document !== 'undefined' && document;\n  if (context && context.nodeType === 9 && !contextDocument) {\n    contextDocument = context;\n  }\n  context = context || contextDocument;\n  isContextXML = isXML(context);\n  for (; groupIndex < groupLen; groupIndex++) {\n    resetStatus();\n    group = selector[groupIndex];\n    var suffix = group.suffix,\n      suffixIndex,\n      suffixLen,\n      seedsIndex,\n      mySeeds = seeds,\n      seedsLen,\n      id = null;\n    if (!mySeeds) {\n      if (suffix && !isContextXML) {\n        suffixIndex = 0;\n        suffixLen = suffix.length;\n        for (; suffixIndex < suffixLen; suffixIndex++) {\n          var singleSuffix = suffix[suffixIndex];\n          if (singleSuffix.t === 'id') {\n            id = singleSuffix.value;\n            break;\n          }\n        }\n      }\n      if (id) {\n        // http://yiminghe.github.io/lab/playground/fragment-selector/selector.html\n        var doesNotHasById = !context.getElementById,\n          contextInDom = util.contains(contextDocument, context),\n          tmp = doesNotHasById ? contextInDom ? contextDocument.getElementById(id) : null : context.getElementById(id);\n        // id bug\n        // https://github.com/kissyteam/kissy/issues/67\n        if (!tmp && doesNotHasById || tmp && getAttr(tmp, 'id') !== id) {\n          var tmps = util.getElementsByTagName('*', context),\n            tmpLen = tmps.length,\n            tmpI = 0;\n          for (; tmpI < tmpLen; tmpI++) {\n            tmp = tmps[tmpI];\n            if (getAttr(tmp, 'id') === id) {\n              mySeeds = [tmp];\n              break;\n            }\n          }\n          if (tmpI === tmpLen) {\n            mySeeds = [];\n          }\n        } else {\n          if (contextInDom && tmp && context !== contextDocument) {\n            tmp = util.contains(context, tmp) ? tmp : null;\n          }\n          mySeeds = tmp ? [tmp] : [];\n        }\n      } else {\n        mySeeds = util.getElementsByTagName(group.value || '*', context);\n      }\n    }\n    seedsIndex = 0;\n    seedsLen = mySeeds.length;\n    if (!seedsLen) {\n      continue;\n    }\n    for (; seedsIndex < seedsLen; seedsIndex++) {\n      var seed = mySeeds[seedsIndex];\n      var matchHead = findFixedMatchFromHead(seed, group);\n      if (matchHead === true) {\n        ret.push(seed);\n      } else if (matchHead) {\n        if (matchSub(matchHead.el, matchHead.match)) {\n          ret.push(seed);\n        }\n      }\n    }\n  }\n  if (groupLen > 1) {\n    ret = util.unique(ret);\n  }\n  return ret;\n}\nmodule.exports = select;\nselect.parse = function (str) {\n  return parser.parse(str);\n};\nselect.matches = matches;\nselect.util = util;\nselect.version = '@VERSION@';\n/**\n * @ignore\n * note 2013-03-28\n *  - use recursive call to replace backtracking algorithm\n *\n * refer\n *  - http://www.w3.org/TR/selectors/\n *  - http://www.impressivewebs.com/browser-support-css3-selectors/\n *  - http://blogs.msdn.com/ie/archive/2010/05/13/the-css-corner-css3-selectors.aspx\n *  - http://sizzlejs.com/\n */","map":{"version":3,"names":["util","require","parser","EXPANDO_SELECTOR_KEY","caches","isContextXML","uuid","subMatchesCache","getAttr","el","name","getSimpleAttr","attr","hasSingleClass","isTag","aNPlusB","unescape","unescapeFn","_","escaped","high","isNaN","String","fromCharCode","matchExpr","pseudoFnExpr","nth-child","param","ab","getAb","a","b","index","parent","parentNode","childNodes","count","child","ret","len","length","nodeType","matchIndexByAb","undefined","nth-last-child","nth-of-type","elType","tagName","nth-last-of-type","lang","elLang","unEscape","toLowerCase","getAttribute","indexOf","not","negationArg","t","value","pseudoIdentExpr","empty","root","ownerDocument","documentElement","first-child","last-child","first-of-type","last-of-type","only-child","only-of-type","focus","doc","activeElement","hasFocus","type","href","tabIndex","target","hash","location","slice","enabled","disabled","checked","nodeName","selected","attributeExpr","~=","elValue","|=","^=","startsWith","$=","endsWith","*=","=","relativeExpr","dir","immediate","tag","cls","id","attrib","ident","match","matchFn","pseudo","fn","fnStr","SyntaxError","str","replace","lexer","yy","trim","unEscapeStr","resetStatus","direction","parseInt","eq","isXML","elem","matches","seeds","select","singleMatch","matched","matchSuffix","suffix","matchSuffixLen","matchSuffixIndex","singleMatchSuffix","singleMatchSuffixType","matchImmediate","startEl","relativeOp","startMatch","prev","nextCombinator","findFixedMatchFromHead","head","cur","genId","selectorId","setAttribute","Date","matchSub","matchKey","order","matchSubInternal","matchImmediateRet","context","parse","selector","groupIndex","groupLen","contextDocument","group","document","suffixIndex","suffixLen","seedsIndex","mySeeds","seedsLen","singleSuffix","doesNotHasById","getElementById","contextInDom","contains","tmp","tmps","getElementsByTagName","tmpLen","tmpI","seed","matchHead","push","unique","module","exports","version"],"sources":["/Users/sonodaryuuichirou/Desktop/practice/node_modules/query-selector/lib/query-selector.js"],"sourcesContent":["/**\n * @ignore\n * css3 selector engine for ie6-8\n * @author yiminghe@gmail.com\n */\n\nvar util = require('./query-selector/util');\nvar parser = require('./query-selector/parser');\n\nvar EXPANDO_SELECTOR_KEY = '_ks_data_selector_id_',\n  caches = {},\n  isContextXML,\n  uuid = 0,\n  subMatchesCache = {},\n  getAttr = function (el, name) {\n    if (isContextXML) {\n      return util.getSimpleAttr(el, name);\n    } else {\n      return util.attr(el, name);\n    }\n  },\n  hasSingleClass = util.hasSingleClass,\n  isTag = util.isTag,\n  aNPlusB = /^(([+-]?(?:\\d+)?)?n)?([+-]?\\d+)?$/;\n\n// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\nvar unescape = /\\\\([\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|.)/g,\n  unescapeFn = function (_, escaped) {\n    var high = '0x' + escaped - 0x10000;\n    // NaN means non-codepoint\n    return isNaN(high) ?\n      escaped :\n      // BMP codepoint\n      high < 0 ?\n        String.fromCharCode(high + 0x10000) :\n        // Supplemental Plane codepoint (surrogate pair)\n        String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n  };\n\nvar matchExpr;\n\nvar pseudoFnExpr = {\n  'nth-child': function (el, param) {\n    var ab = getAb(param),\n      a = ab.a,\n      b = ab.b;\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n    var index = 0,\n      parent = el.parentNode;\n    if (parent) {\n      var childNodes = parent.childNodes,\n        count = 0,\n        child,\n        ret,\n        len = childNodes.length;\n      for (; count < len; count++) {\n        child = childNodes[count];\n        if (child.nodeType === 1) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n    return 0;\n  },\n  'nth-last-child': function (el, param) {\n    var ab = getAb(param),\n      a = ab.a,\n      b = ab.b;\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n    var index = 0,\n      parent = el.parentNode;\n    if (parent) {\n      var childNodes = parent.childNodes,\n        len = childNodes.length,\n        count = len - 1,\n        child,\n        ret;\n      for (; count >= 0; count--) {\n        child = childNodes[count];\n        if (child.nodeType === 1) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n    return 0;\n  },\n  'nth-of-type': function (el, param) {\n    var ab = getAb(param),\n      a = ab.a,\n      b = ab.b;\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n    var index = 0,\n      parent = el.parentNode;\n    if (parent) {\n      var childNodes = parent.childNodes,\n        elType = el.tagName,\n        count = 0,\n        child,\n        ret,\n        len = childNodes.length;\n      for (; count < len; count++) {\n        child = childNodes[count];\n        if (child.tagName === elType) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n    return 0;\n  },\n  'nth-last-of-type': function (el, param) {\n    var ab = getAb(param),\n      a = ab.a,\n      b = ab.b;\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n    var index = 0,\n      parent = el.parentNode;\n    if (parent) {\n      var childNodes = parent.childNodes,\n        len = childNodes.length,\n        elType = el.tagName,\n        count = len - 1,\n        child,\n        ret;\n      for (; count >= 0; count--) {\n        child = childNodes[count];\n        if (child.tagName === elType) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n    return 0;\n  },\n  lang: function (el, lang) {\n    var elLang;\n    lang = unEscape(lang.toLowerCase());\n    do {\n      if ((elLang = (isContextXML ?\n        el.getAttribute('xml:lang') || el.getAttribute('lang') :\n          el.lang))) {\n        elLang = elLang.toLowerCase();\n        return elLang === lang || elLang.indexOf(lang + '-') === 0;\n      }\n    } while ((el = el.parentNode) && el.nodeType === 1);\n    return false;\n  },\n  not: function (el, negationArg) {\n    return !matchExpr[negationArg.t](el, negationArg.value);\n  }\n};\n\nvar pseudoIdentExpr = {\n  empty: function (el) {\n    var childNodes = el.childNodes,\n      index = 0,\n      len = childNodes.length - 1,\n      child,\n      nodeType;\n    for (; index < len; index++) {\n      child = childNodes[index];\n      nodeType = child.nodeType;\n      // only element nodes and content nodes\n      // (such as Dom [Dom-LEVEL-3-CORE] text nodes,\n      // CDATA nodes, and entity references\n      if (nodeType === 1 || nodeType === 3 || nodeType === 4 || nodeType === 5) {\n        return 0;\n      }\n    }\n    return 1;\n  },\n  root: function (el) {\n    if (el.nodeType === 9) {\n      return true;\n    }\n    return el.ownerDocument &&\n      el === el.ownerDocument.documentElement;\n  },\n  'first-child': function (el) {\n    return pseudoFnExpr['nth-child'](el, 1);\n  },\n  'last-child': function (el) {\n    return pseudoFnExpr['nth-last-child'](el, 1);\n  },\n  'first-of-type': function (el) {\n    return pseudoFnExpr['nth-of-type'](el, 1);\n  },\n  'last-of-type': function (el) {\n    return pseudoFnExpr['nth-last-of-type'](el, 1);\n  },\n  'only-child': function (el) {\n    return pseudoIdentExpr['first-child'](el) &&\n      pseudoIdentExpr['last-child'](el);\n  },\n  'only-of-type': function (el) {\n    return pseudoIdentExpr['first-of-type'](el) &&\n      pseudoIdentExpr['last-of-type'](el);\n  },\n  focus: function (el) {\n    var doc = el.ownerDocument;\n    return doc && el === doc.activeElement &&\n      (!doc.hasFocus || doc.hasFocus()) && !!(el.type || el.href || el.tabIndex >= 0);\n  },\n  target: function (el) {\n    var hash = location.hash;\n    return hash && hash.slice(1) === getAttr(el, 'id');\n  },\n  enabled: function (el) {\n    return !el.disabled;\n  },\n  disabled: function (el) {\n    return el.disabled;\n  },\n  checked: function (el) {\n    var nodeName = el.nodeName.toLowerCase();\n    return (nodeName === 'input' && el.checked) ||\n      (nodeName === 'option' && el.selected);\n  }\n};\n\nvar attributeExpr = {\n  '~=': function (elValue, value) {\n    if (!value || value.indexOf(' ') > -1) {\n      return 0;\n    }\n    return (' ' + elValue + ' ').indexOf(' ' + value + ' ') !== -1;\n  },\n  '|=': function (elValue, value) {\n    return (' ' + elValue).indexOf(' ' + value + '-') !== -1;\n  },\n  '^=': function (elValue, value) {\n    return value && util.startsWith(elValue, value);\n  },\n  '$=': function (elValue, value) {\n    return value && util.endsWith(elValue, value);\n  },\n  '*=': function (elValue, value) {\n    return value && elValue.indexOf(value) !== -1;\n  },\n  '=': function (elValue, value) {\n    return elValue === value;\n  }\n};\n\nvar relativeExpr = {\n  '>': {\n    dir: 'parentNode',\n    immediate: 1\n  },\n  ' ': {\n    dir: 'parentNode'\n  },\n  '+': {\n    dir: 'previousSibling',\n    immediate: 1\n  },\n  '~': {\n    dir: 'previousSibling'\n  }\n};\n\nmatchExpr = {\n  tag: isTag,\n  cls: hasSingleClass,\n  id: function (el, value) {\n    return getAttr(el, 'id') === value;\n  },\n  attrib: function (el, value) {\n    var name = value.ident;\n    if (!isContextXML) {\n      name = name.toLowerCase();\n    }\n    var elValue = getAttr(el, name);\n    var match = value.match;\n    if (!match && elValue !== undefined) {\n      return 1;\n    } else if (match) {\n      if (elValue === undefined) {\n        return 0;\n      }\n      var matchFn = attributeExpr[match];\n      if (matchFn) {\n        return matchFn(elValue + '', value.value + '');\n      }\n    }\n    return 0;\n  },\n  pseudo: function (el, value) {\n    var fn, fnStr, ident;\n    if ((fnStr = value.fn)) {\n      if (!(fn = pseudoFnExpr[fnStr])) {\n        throw new SyntaxError('Syntax error: not support pseudo: ' + fnStr);\n      }\n      return fn(el, value.param);\n    }\n    if ((ident = value.ident)) {\n      if (!pseudoIdentExpr[ident]) {\n        throw new SyntaxError('Syntax error: not support pseudo: ' + ident);\n      }\n      return pseudoIdentExpr[ident](el);\n    }\n    return 0;\n  }\n};\n\nfunction unEscape(str) {\n  return str.replace(unescape, unescapeFn);\n}\n\nparser.lexer.yy = {\n  trim: util.trim,\n  unEscape: unEscape,\n  unEscapeStr: function (str) {\n    return this.unEscape(str.slice(1, -1));\n  }\n};\n\nfunction resetStatus() {\n  subMatchesCache = {};\n}\n\nfunction dir(el, direction) {\n  do {\n    el = el[direction];\n  } while (el && el.nodeType !== 1);\n  return el;\n}\n\nfunction getAb(param) {\n  var a = 0,\n    match,\n    b = 0;\n  if (typeof param === 'number') {\n    b = param;\n  } else if (param === 'odd') {\n    a = 2;\n    b = 1;\n  } else if (param === 'even') {\n    a = 2;\n    b = 0;\n  } else if ((match = param.replace(/\\s/g, '').match(aNPlusB))) {\n    if (match[1]) {\n      a = parseInt(match[2], 10);\n      if (isNaN(a)) {\n        if (match[2] === '-') {\n          a = -1;\n        } else {\n          a = 1;\n        }\n      }\n    } else {\n      a = 0;\n    }\n    b = parseInt(match[3], 10) || 0;\n  }\n  return {\n    a: a,\n    b: b\n  };\n}\n\nfunction matchIndexByAb(index, a, b, eq) {\n  if (a === 0) {\n    if (index === b) {\n      return eq;\n    }\n  } else {\n    if ((index - b) / a >= 0 && (index - b) % a === 0 && eq) {\n      return 1;\n    }\n  }\n  return undefined;\n}\n\nfunction isXML(elem) {\n  var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n  return documentElement ? documentElement.nodeName.toLowerCase() !== 'html' : false;\n}\n\nfunction matches(str, seeds) {\n  return select(str, null, seeds);\n}\n\nfunction singleMatch(el, match) {\n  if (!match) {\n    return true;\n  }\n  if (!el) {\n    return false;\n  }\n\n  if (el.nodeType === 9) {\n    return false;\n  }\n\n  var matched = 1,\n    matchSuffix = match.suffix,\n    matchSuffixLen,\n    matchSuffixIndex;\n\n  if (match.t === 'tag') {\n    matched &= matchExpr.tag(el, match.value);\n  }\n\n  if (matched && matchSuffix) {\n    matchSuffixLen = matchSuffix.length;\n    matchSuffixIndex = 0;\n    for (; matched && matchSuffixIndex < matchSuffixLen; matchSuffixIndex++) {\n      var singleMatchSuffix = matchSuffix[matchSuffixIndex],\n        singleMatchSuffixType = singleMatchSuffix.t;\n      if (matchExpr[singleMatchSuffixType]) {\n        matched &= matchExpr[singleMatchSuffixType](el, singleMatchSuffix.value);\n      }\n    }\n  }\n\n  return matched;\n}\n\n// match by adjacent immediate single selector match\nfunction matchImmediate(el, match) {\n  var matched = 1,\n    startEl = el,\n    relativeOp,\n    startMatch = match;\n\n  do {\n    matched &= singleMatch(el, match);\n    if (matched) {\n      // advance\n      match = match && match.prev;\n      if (!match) {\n        return true;\n      }\n      relativeOp = relativeExpr[match.nextCombinator];\n      el = dir(el, relativeOp.dir);\n      if (!relativeOp.immediate) {\n        return {\n          // advance for non-immediate\n          el: el,\n          match: match\n        };\n      }\n    } else {\n      relativeOp = relativeExpr[match.nextCombinator];\n      if (relativeOp.immediate) {\n        // retreat but advance startEl\n        return {\n          el: dir(startEl, relativeExpr[startMatch.nextCombinator].dir),\n          match: startMatch\n        };\n      } else {\n        // advance (before immediate match + jump unmatched)\n        return {\n          el: el && dir(el, relativeOp.dir),\n          match: match\n        };\n      }\n    }\n  } while (el);\n\n  // only occur when match immediate\n  return {\n    el: dir(startEl, relativeExpr[startMatch.nextCombinator].dir),\n    match: startMatch\n  };\n}\n\n// find fixed part, fixed with seeds\nfunction findFixedMatchFromHead(el, head) {\n  var relativeOp,\n    cur = head;\n\n  do {\n    if (!singleMatch(el, cur)) {\n      return null;\n    }\n    cur = cur.prev;\n    if (!cur) {\n      return true;\n    }\n    relativeOp = relativeExpr[cur.nextCombinator];\n    el = dir(el, relativeOp.dir);\n  } while (el && relativeOp.immediate);\n  if (!el) {\n    return null;\n  }\n  return {\n    el: el,\n    match: cur\n  };\n}\n\nfunction genId(el) {\n  var selectorId;\n\n  if (isContextXML) {\n    if (!(selectorId = el.getAttribute(EXPANDO_SELECTOR_KEY))) {\n      el.setAttribute(EXPANDO_SELECTOR_KEY, selectorId = (+new Date() + '_' + (++uuid)));\n    }\n  } else {\n    if (!(selectorId = el[EXPANDO_SELECTOR_KEY])) {\n      selectorId = el[EXPANDO_SELECTOR_KEY] = (+new Date()) + '_' + (++uuid);\n    }\n  }\n\n  return selectorId;\n}\n\nfunction matchSub(el, match) {\n  var selectorId = genId(el),\n    matchKey;\n  matchKey = selectorId + '_' + (match.order || 0);\n  if (matchKey in subMatchesCache) {\n    return subMatchesCache[matchKey];\n  }\n  subMatchesCache[matchKey] = matchSubInternal(el, match);\n  return subMatchesCache[matchKey];\n}\n\n// recursive match by sub selector string from right to left\n// grouped by immediate selectors\nfunction matchSubInternal(el, match) {\n  var matchImmediateRet = matchImmediate(el, match);\n  if (matchImmediateRet === true) {\n    return true;\n  } else {\n    el = matchImmediateRet.el;\n    match = matchImmediateRet.match;\n    while (el) {\n      if (matchSub(el, match)) {\n        return true;\n      }\n      el = dir(el, relativeExpr[match.nextCombinator].dir);\n    }\n    return false;\n  }\n}\n\nfunction select(str, context, seeds) {\n  if (!caches[str]) {\n    caches[str] = parser.parse(str);\n  }\n\n  var selector = caches[str],\n    groupIndex = 0,\n    groupLen = selector.length,\n    contextDocument,\n    group,\n    ret = [];\n\n  if (seeds) {\n    context = context || seeds[0].ownerDocument;\n  }\n\n  contextDocument = context && context.ownerDocument || typeof document !== 'undefined' && document;\n\n  if (context && context.nodeType === 9 && !contextDocument) {\n    contextDocument = context;\n  }\n\n  context = context || contextDocument;\n\n  isContextXML = isXML(context);\n\n  for (; groupIndex < groupLen; groupIndex++) {\n    resetStatus();\n\n    group = selector[groupIndex];\n\n    var suffix = group.suffix,\n      suffixIndex,\n      suffixLen,\n      seedsIndex,\n      mySeeds = seeds,\n      seedsLen,\n      id = null;\n\n    if (!mySeeds) {\n      if (suffix && !isContextXML) {\n        suffixIndex = 0;\n        suffixLen = suffix.length;\n        for (; suffixIndex < suffixLen; suffixIndex++) {\n          var singleSuffix = suffix[suffixIndex];\n          if (singleSuffix.t === 'id') {\n            id = singleSuffix.value;\n            break;\n          }\n        }\n      }\n\n      if (id) {\n        // http://yiminghe.github.io/lab/playground/fragment-selector/selector.html\n        var doesNotHasById = !context.getElementById,\n          contextInDom = util.contains(contextDocument, context),\n          tmp = doesNotHasById ? (\n            contextInDom ?\n              contextDocument.getElementById(id) :\n              null\n          ) : context.getElementById(id);\n        // id bug\n        // https://github.com/kissyteam/kissy/issues/67\n        if (!tmp && doesNotHasById || tmp && getAttr(tmp, 'id') !== id) {\n          var tmps = util.getElementsByTagName('*', context),\n            tmpLen = tmps.length,\n            tmpI = 0;\n          for (; tmpI < tmpLen; tmpI++) {\n            tmp = tmps[tmpI];\n            if (getAttr(tmp, 'id') === id) {\n              mySeeds = [tmp];\n              break;\n            }\n          }\n          if (tmpI === tmpLen) {\n            mySeeds = [];\n          }\n        } else {\n          if (contextInDom && tmp && context !== contextDocument) {\n            tmp = util.contains(context, tmp) ? tmp : null;\n          }\n          mySeeds = tmp ? [tmp] : [];\n        }\n      } else {\n        mySeeds = util.getElementsByTagName(group.value || '*', context);\n      }\n    }\n\n    seedsIndex = 0;\n    seedsLen = mySeeds.length;\n\n    if (!seedsLen) {\n      continue;\n    }\n\n    for (; seedsIndex < seedsLen; seedsIndex++) {\n      var seed = mySeeds[seedsIndex];\n      var matchHead = findFixedMatchFromHead(seed, group);\n      if (matchHead === true) {\n        ret.push(seed);\n      } else if (matchHead) {\n        if (matchSub(matchHead.el, matchHead.match)) {\n          ret.push(seed);\n        }\n      }\n    }\n  }\n\n  if (groupLen > 1) {\n    ret = util.unique(ret);\n  }\n\n  return ret;\n}\n\nmodule.exports = select;\n\nselect.parse = function (str) {\n  return parser.parse(str);\n};\n\nselect.matches = matches;\n\nselect.util = util;\n\nselect.version = '@VERSION@';\n/**\n * @ignore\n * note 2013-03-28\n *  - use recursive call to replace backtracking algorithm\n *\n * refer\n *  - http://www.w3.org/TR/selectors/\n *  - http://www.impressivewebs.com/browser-support-css3-selectors/\n *  - http://blogs.msdn.com/ie/archive/2010/05/13/the-css-corner-css3-selectors.aspx\n *  - http://sizzlejs.com/\n */"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
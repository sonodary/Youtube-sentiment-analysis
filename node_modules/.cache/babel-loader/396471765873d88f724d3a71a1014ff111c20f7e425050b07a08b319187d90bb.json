{"ast":null,"code":"/*:: type Attr = { [key: string]: string | number } */\n/*:: type Opts = { preserveNumbers: ?boolean } */\n\n/*\n\nstyle-attr\n====\n\nVery simple parsing and stringifying of style attributes.\n\n`parse`\n----\n\nConvert a style attribute string to an object.\n\n*/\n\n/*:: declare function parse (raw: string, opts: ?Opts): Attr */\nfunction parse(raw, opts) {\n  opts = opts || {};\n  var preserveNumbers = opts.preserveNumbers;\n  var trim = function (s) {\n    return s.trim();\n  };\n  var obj = {};\n  getKeyValueChunks(raw).map(trim).filter(Boolean).forEach(function (item) {\n    // split with `.indexOf` rather than `.split` because the value may also contain colons.\n    var pos = item.indexOf(':');\n    var key = item.substr(0, pos).trim();\n    var val = item.substr(pos + 1).trim();\n    if (preserveNumbers && isNumeric(val)) {\n      val = Number(val);\n    }\n    obj[key] = val;\n  });\n  return obj;\n}\n\n/*\n\n`isNumeric`\n----\n\nCheck if a value is numeric.\nVia: https://stackoverflow.com/a/1830844/9324\n\n*/\n\n/*:: declare function isNumeric (n: any): boolean */\n\nfunction isNumeric(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/*\n\n`getKeyValueChunks`\n----\n\nSplit a string into chunks matching `<key>: <value>`\n\n*/\n/*:: declare function getKeyValueChunks (raw: string): Array<string> */\nfunction getKeyValueChunks(raw) {\n  var chunks = [];\n  var offset = 0;\n  var sep = ';';\n  var hasUnclosedUrl = /url\\([^\\)]+$/;\n  var chunk = '';\n  var nextSplit;\n  while (offset < raw.length) {\n    nextSplit = raw.indexOf(sep, offset);\n    if (nextSplit === -1) {\n      nextSplit = raw.length;\n    }\n    chunk += raw.substring(offset, nextSplit);\n\n    // data URIs can contain semicolons, so make sure we get the whole thing\n    if (hasUnclosedUrl.test(chunk)) {\n      chunk += ';';\n      offset = nextSplit + 1;\n      continue;\n    }\n    chunks.push(chunk);\n    chunk = '';\n    offset = nextSplit + 1;\n  }\n  return chunks;\n}\n\n/*\n\n`stringify`\n----\n\nConvert an object into an attribute string\n\n*/\n/*:: declare function stringify (obj: Attr): string */\nfunction stringify(obj) {\n  return Object.keys(obj).map(function (key) {\n    return key + ':' + obj[key];\n  }).join(';');\n}\n\n/*\n\n`normalize`\n----\n\nNormalize an attribute string (eg. collapse duplicates)\n\n*/\n/*:: declare function normalize (str: string, opts: ?Opts): string */\nfunction normalize(str, opts) {\n  return stringify(parse(str, opts));\n}\nmodule.exports.parse = parse;\nmodule.exports.stringify = stringify;\nmodule.exports.normalize = normalize;","map":{"version":3,"names":["parse","raw","opts","preserveNumbers","trim","s","obj","getKeyValueChunks","map","filter","Boolean","forEach","item","pos","indexOf","key","substr","val","isNumeric","Number","n","isNaN","parseFloat","isFinite","chunks","offset","sep","hasUnclosedUrl","chunk","nextSplit","length","substring","test","push","stringify","Object","keys","join","normalize","str","module","exports"],"sources":["/Users/sonodaryuuichirou/Desktop/practice/node_modules/style-attr/lib/index.js"],"sourcesContent":["\n\n/*:: type Attr = { [key: string]: string | number } */\n/*:: type Opts = { preserveNumbers: ?boolean } */\n\n/*\n\nstyle-attr\n====\n\nVery simple parsing and stringifying of style attributes.\n\n`parse`\n----\n\nConvert a style attribute string to an object.\n\n*/\n\n/*:: declare function parse (raw: string, opts: ?Opts): Attr */\nfunction parse(raw, opts) {\n  opts = opts || {};\n\n  var preserveNumbers = opts.preserveNumbers;\n  var trim = function (s) {\n    return s.trim();\n  };\n  var obj = {};\n\n  getKeyValueChunks(raw).map(trim).filter(Boolean).forEach(function (item) {\n    // split with `.indexOf` rather than `.split` because the value may also contain colons.\n    var pos = item.indexOf(':');\n    var key = item.substr(0, pos).trim();\n    var val = item.substr(pos + 1).trim();\n    if (preserveNumbers && isNumeric(val)) {\n      val = Number(val);\n    }\n\n    obj[key] = val;\n  });\n\n  return obj;\n}\n\n/*\n\n`isNumeric`\n----\n\nCheck if a value is numeric.\nVia: https://stackoverflow.com/a/1830844/9324\n\n*/\n\n/*:: declare function isNumeric (n: any): boolean */\n\nfunction isNumeric(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/*\n\n`getKeyValueChunks`\n----\n\nSplit a string into chunks matching `<key>: <value>`\n\n*/\n/*:: declare function getKeyValueChunks (raw: string): Array<string> */\nfunction getKeyValueChunks(raw) {\n  var chunks = [];\n  var offset = 0;\n  var sep = ';';\n  var hasUnclosedUrl = /url\\([^\\)]+$/;\n  var chunk = '';\n  var nextSplit;\n  while (offset < raw.length) {\n    nextSplit = raw.indexOf(sep, offset);\n    if (nextSplit === -1) {\n      nextSplit = raw.length;\n    }\n\n    chunk += raw.substring(offset, nextSplit);\n\n    // data URIs can contain semicolons, so make sure we get the whole thing\n    if (hasUnclosedUrl.test(chunk)) {\n      chunk += ';';\n      offset = nextSplit + 1;\n      continue;\n    }\n\n    chunks.push(chunk);\n    chunk = '';\n    offset = nextSplit + 1;\n  }\n\n  return chunks;\n}\n\n/*\n\n`stringify`\n----\n\nConvert an object into an attribute string\n\n*/\n/*:: declare function stringify (obj: Attr): string */\nfunction stringify(obj) {\n  return Object.keys(obj).map(function (key) {\n    return key + ':' + obj[key];\n  }).join(';');\n}\n\n/*\n\n`normalize`\n----\n\nNormalize an attribute string (eg. collapse duplicates)\n\n*/\n/*:: declare function normalize (str: string, opts: ?Opts): string */\nfunction normalize(str, opts) {\n  return stringify(parse(str, opts));\n}\n\nmodule.exports.parse = parse;\nmodule.exports.stringify = stringify;\nmodule.exports.normalize = normalize;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}